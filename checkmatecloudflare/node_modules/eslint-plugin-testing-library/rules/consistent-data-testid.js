"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RULE_NAME = void 0;
<<<<<<< HEAD
var utils_1 = require("../utils");
var experimental_utils_1 = require("@typescript-eslint/experimental-utils");
var node_utils_1 = require("../node-utils");
exports.RULE_NAME = 'consistent-data-testid';
var FILENAME_PLACEHOLDER = '{fileName}';
exports.default = experimental_utils_1.ESLintUtils.RuleCreator(utils_1.getDocsUrl)({
=======
const create_testing_library_rule_1 = require("../create-testing-library-rule");
const node_utils_1 = require("../node-utils");
exports.RULE_NAME = 'consistent-data-testid';
const FILENAME_PLACEHOLDER = '{fileName}';
exports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({
>>>>>>> features/task-display-and-function
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Ensures consistent usage of `data-testid`',
<<<<<<< HEAD
            category: 'Best Practices',
            recommended: false,
        },
        messages: {
            invalidTestId: '`{{attr}}` "{{value}}" should match `{{regex}}`',
        },
        fixable: null,
=======
            recommendedConfig: {
                dom: false,
                angular: false,
                react: false,
                vue: false,
                marko: false,
            },
        },
        messages: {
            consistentDataTestId: '`{{attr}}` "{{value}}" should match `{{regex}}`',
            consistentDataTestIdCustomMessage: '`{{message}}`',
        },
>>>>>>> features/task-display-and-function
        schema: [
            {
                type: 'object',
                default: {},
                additionalProperties: false,
                required: ['testIdPattern'],
                properties: {
                    testIdPattern: {
                        type: 'string',
                    },
                    testIdAttribute: {
                        default: 'data-testid',
                        oneOf: [
                            {
                                type: 'string',
                            },
                            {
                                type: 'array',
                                items: {
                                    type: 'string',
                                },
                            },
                        ],
                    },
<<<<<<< HEAD
=======
                    customMessage: {
                        default: undefined,
                        type: 'string',
                    },
>>>>>>> features/task-display-and-function
                },
            },
        ],
    },
    defaultOptions: [
        {
            testIdPattern: '',
            testIdAttribute: 'data-testid',
<<<<<<< HEAD
        },
    ],
    create: function (context, _a) {
        var _b;
        var options = _a[0];
        var getFilename = context.getFilename;
        var testIdPattern = options.testIdPattern, attr = options.testIdAttribute;
        function getFileNameData() {
            var splitPath = getFilename().split('/');
            var fileNameWithExtension = splitPath.pop();
            var parent = splitPath.pop();
            var fileName = fileNameWithExtension.split('.').shift();
=======
            customMessage: undefined,
        },
    ],
    detectionOptions: {
        skipRuleReportingCheck: true,
    },
    create: (context, [options]) => {
        const { getFilename } = context;
        const { testIdPattern, testIdAttribute: attr, customMessage } = options;
        function getFileNameData() {
            var _a;
            const splitPath = getFilename().split('/');
            const fileNameWithExtension = (_a = splitPath.pop()) !== null && _a !== void 0 ? _a : '';
            if (fileNameWithExtension.includes('[') ||
                fileNameWithExtension.includes(']')) {
                return { fileName: undefined };
            }
            const parent = splitPath.pop();
            const fileName = fileNameWithExtension.split('.').shift();
>>>>>>> features/task-display-and-function
            return {
                fileName: fileName === 'index' ? parent : fileName,
            };
        }
        function getTestIdValidator(fileName) {
            return new RegExp(testIdPattern.replace(FILENAME_PLACEHOLDER, fileName));
        }
        function isTestIdAttribute(name) {
<<<<<<< HEAD
=======
            var _a;
>>>>>>> features/task-display-and-function
            if (typeof attr === 'string') {
                return attr === name;
            }
            else {
<<<<<<< HEAD
                return attr.includes(name);
            }
        }
        return _b = {},
            _b["JSXIdentifier"] = function (node) {
                if (!node_utils_1.isJSXAttribute(node.parent) ||
                    !node_utils_1.isLiteral(node.parent.value) ||
                    !isTestIdAttribute(node.name)) {
                    return;
                }
                var value = node.parent.value.value;
                var fileName = getFileNameData().fileName;
                var regex = getTestIdValidator(fileName);
                if (value && typeof value === 'string' && !regex.test(value)) {
                    context.report({
                        node: node,
                        messageId: 'invalidTestId',
                        data: {
                            attr: node.name,
                            value: value,
                            regex: regex,
=======
                return (_a = attr === null || attr === void 0 ? void 0 : attr.includes(name)) !== null && _a !== void 0 ? _a : false;
            }
        }
        function getErrorMessageId() {
            if (customMessage === undefined) {
                return 'consistentDataTestId';
            }
            return 'consistentDataTestIdCustomMessage';
        }
        return {
            JSXIdentifier: (node) => {
                if (!node.parent ||
                    !(0, node_utils_1.isJSXAttribute)(node.parent) ||
                    !(0, node_utils_1.isLiteral)(node.parent.value) ||
                    !isTestIdAttribute(node.name)) {
                    return;
                }
                const value = node.parent.value.value;
                const { fileName } = getFileNameData();
                const regex = getTestIdValidator(fileName !== null && fileName !== void 0 ? fileName : '');
                if (value && typeof value === 'string' && !regex.test(value)) {
                    context.report({
                        node,
                        messageId: getErrorMessageId(),
                        data: {
                            attr: node.name,
                            value,
                            regex,
                            message: customMessage,
>>>>>>> features/task-display-and-function
                        },
                    });
                }
            },
<<<<<<< HEAD
            _b;
=======
        };
>>>>>>> features/task-display-and-function
    },
});
