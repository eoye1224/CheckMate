<<<<<<< HEAD
'use strict';

const path = require('path');
const emojisList = require('emojis-list');
const getHashDigest = require('./getHashDigest');

const emojiRegex = /[\uD800-\uDFFF]./;
const emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));
const emojiCache = {};

function encodeStringToEmoji(content, length) {
  if (emojiCache[content]) {
    return emojiCache[content];
  }

  length = length || 1;

  const emojis = [];

  do {
    if (!emojiList.length) {
      throw new Error('Ran out of emoji');
    }

    const index = Math.floor(Math.random() * emojiList.length);

    emojis.push(emojiList[index]);
    emojiList.splice(index, 1);
  } while (--length > 0);

  const emojiEncoding = emojis.join('');

  emojiCache[content] = emojiEncoding;

  return emojiEncoding;
}

function interpolateName(loaderContext, name, options) {
=======
"use strict";

const path = require("path");
const getHashDigest = require("./getHashDigest");

function interpolateName(loaderContext, name, options = {}) {
>>>>>>> features/task-display-and-function
  let filename;

  const hasQuery =
    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;

<<<<<<< HEAD
  if (typeof name === 'function') {
=======
  if (typeof name === "function") {
>>>>>>> features/task-display-and-function
    filename = name(
      loaderContext.resourcePath,
      hasQuery ? loaderContext.resourceQuery : undefined
    );
  } else {
<<<<<<< HEAD
    filename = name || '[hash].[ext]';
=======
    filename = name || "[hash].[ext]";
>>>>>>> features/task-display-and-function
  }

  const context = options.context;
  const content = options.content;
  const regExp = options.regExp;

<<<<<<< HEAD
  let ext = 'bin';
  let basename = 'file';
  let directory = '';
  let folder = '';
  let query = '';
=======
  let ext = "bin";
  let basename = "file";
  let directory = "";
  let folder = "";
  let query = "";
>>>>>>> features/task-display-and-function

  if (loaderContext.resourcePath) {
    const parsed = path.parse(loaderContext.resourcePath);
    let resourcePath = loaderContext.resourcePath;

    if (parsed.ext) {
      ext = parsed.ext.substr(1);
    }

    if (parsed.dir) {
      basename = parsed.name;
      resourcePath = parsed.dir + path.sep;
    }

<<<<<<< HEAD
    if (typeof context !== 'undefined') {
      directory = path
        .relative(context, resourcePath + '_')
        .replace(/\\/g, '/')
        .replace(/\.\.(\/)?/g, '_$1');
      directory = directory.substr(0, directory.length - 1);
    } else {
      directory = resourcePath.replace(/\\/g, '/').replace(/\.\.(\/)?/g, '_$1');
    }

    if (directory.length === 1) {
      directory = '';
    } else if (directory.length > 1) {
=======
    if (typeof context !== "undefined") {
      directory = path
        .relative(context, resourcePath + "_")
        .replace(/\\/g, "/")
        .replace(/\.\.(\/)?/g, "_$1");
      directory = directory.substr(0, directory.length - 1);
    } else {
      directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
    }

    if (directory.length <= 1) {
      directory = "";
    } else {
      // directory.length > 1
>>>>>>> features/task-display-and-function
      folder = path.basename(directory);
    }
  }

  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
    query = loaderContext.resourceQuery;

<<<<<<< HEAD
    const hashIdx = query.indexOf('#');
=======
    const hashIdx = query.indexOf("#");
>>>>>>> features/task-display-and-function

    if (hashIdx >= 0) {
      query = query.substr(0, hashIdx);
    }
  }

  let url = filename;

  if (content) {
    // Match hash template
    url = url
      // `hash` and `contenthash` are same in `loader-utils` context
      // let's keep `hash` for backward compatibility
      .replace(
<<<<<<< HEAD
        /\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi,
        (all, hashType, digestType, maxLength) =>
          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))
      )
      .replace(/\[emoji(?::(\d+))?\]/gi, (all, length) =>
        encodeStringToEmoji(content, parseInt(length, 10))
=======
        /\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*(?:safe)?))?(?::(\d+))?\]/gi,
        (all, hashType, digestType, maxLength) =>
          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))
>>>>>>> features/task-display-and-function
      );
  }

  url = url
    .replace(/\[ext\]/gi, () => ext)
    .replace(/\[name\]/gi, () => basename)
    .replace(/\[path\]/gi, () => directory)
    .replace(/\[folder\]/gi, () => folder)
    .replace(/\[query\]/gi, () => query);

  if (regExp && loaderContext.resourcePath) {
    const match = loaderContext.resourcePath.match(new RegExp(regExp));

    match &&
      match.forEach((matched, i) => {
<<<<<<< HEAD
        url = url.replace(new RegExp('\\[' + i + '\\]', 'ig'), matched);
=======
        url = url.replace(new RegExp("\\[" + i + "\\]", "ig"), matched);
>>>>>>> features/task-display-and-function
      });
  }

  if (
<<<<<<< HEAD
    typeof loaderContext.options === 'object' &&
    typeof loaderContext.options.customInterpolateName === 'function'
=======
    typeof loaderContext.options === "object" &&
    typeof loaderContext.options.customInterpolateName === "function"
>>>>>>> features/task-display-and-function
  ) {
    url = loaderContext.options.customInterpolateName.call(
      loaderContext,
      url,
      name,
      options
    );
  }

  return url;
}

module.exports = interpolateName;
