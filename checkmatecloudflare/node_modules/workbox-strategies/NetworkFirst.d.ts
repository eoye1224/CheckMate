<<<<<<< HEAD
import { RouteHandlerObject, RouteHandlerCallbackOptions, WorkboxPlugin } from 'workbox-core/types.js';
import './_version.js';
interface NetworkFirstOptions {
    cacheName?: string;
    plugins?: WorkboxPlugin[];
    fetchOptions?: RequestInit;
    matchOptions?: CacheQueryOptions;
=======
import { Strategy, StrategyOptions } from './Strategy.js';
import { StrategyHandler } from './StrategyHandler.js';
import './_version.js';
export interface NetworkFirstOptions extends StrategyOptions {
>>>>>>> features/task-display-and-function
    networkTimeoutSeconds?: number;
}
/**
 * An implementation of a
<<<<<<< HEAD
 * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}
 * request strategy.
 *
 * By default, this strategy will cache responses with a 200 status code as
 * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.
 * Opaque responses are are cross-origin requests where the response doesn't
 * support [CORS]{@link https://enable-cors.org/}.
=======
 * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)
 * request strategy.
 *
 * By default, this strategy will cache responses with a 200 status code as
 * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).
 * Opaque responses are are cross-origin requests where the response doesn't
 * support [CORS](https://enable-cors.org/).
>>>>>>> features/task-display-and-function
 *
 * If the network request fails, and there is no cache match, this will throw
 * a `WorkboxError` exception.
 *
<<<<<<< HEAD
 * @memberof module:workbox-strategies
 */
declare class NetworkFirst implements RouteHandlerObject {
    private readonly _cacheName;
    private readonly _plugins;
    private readonly _fetchOptions?;
    private readonly _matchOptions?;
    private readonly _networkTimeoutSeconds;
    /**
     * @param {Object} options
     * @param {string} options.cacheName Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * [workbox-core]{@link module:workbox-core.cacheNames}.
     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} options.fetchOptions Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of all fetch() requests made by this strategy.
     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     * @param {number} options.networkTimeoutSeconds If set, any network requests
=======
 * @extends workbox-strategies.Strategy
 * @memberof workbox-strategies
 */
declare class NetworkFirst extends Strategy {
    private readonly _networkTimeoutSeconds;
    /**
     * @param {Object} [options]
     * @param {string} [options.cacheName] Cache name to store and retrieve
     * requests. Defaults to cache names provided by
     * {@link workbox-core.cacheNames}.
     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
     * to use in conjunction with this caching strategy.
     * @param {Object} [options.fetchOptions] Values passed along to the
     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
     * `fetch()` requests made by this strategy.
     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
     * @param {number} [options.networkTimeoutSeconds] If set, any network requests
>>>>>>> features/task-display-and-function
     * that fail to respond within the timeout will fallback to the cache.
     *
     * This option can be used to combat
     * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
     * scenarios.
     */
    constructor(options?: NetworkFirstOptions);
    /**
<<<<<<< HEAD
     * This method will perform a request strategy and follows an API that
     * will work with the
     * [Workbox Router]{@link module:workbox-routing.Router}.
     *
     * @param {Object} options
     * @param {Request|string} options.request A request to run this strategy for.
     * @param {Event} [options.event] The event that triggered the request.
     * @return {Promise<Response>}
     */
    handle({ event, request }: RouteHandlerCallbackOptions): Promise<Response>;
=======
     * @private
     * @param {Request|string} request A request to run this strategy for.
     * @param {workbox-strategies.StrategyHandler} handler The event that
     *     triggered the request.
     * @return {Promise<Response>}
     */
    _handle(request: Request, handler: StrategyHandler): Promise<Response>;
>>>>>>> features/task-display-and-function
    /**
     * @param {Object} options
     * @param {Request} options.request
     * @param {Array} options.logs A reference to the logs array
<<<<<<< HEAD
     * @param {Event} [options.event]
=======
     * @param {Event} options.event
>>>>>>> features/task-display-and-function
     * @return {Promise<Response>}
     *
     * @private
     */
    private _getTimeoutPromise;
    /**
     * @param {Object} options
     * @param {number|undefined} options.timeoutId
     * @param {Request} options.request
     * @param {Array} options.logs A reference to the logs Array.
<<<<<<< HEAD
     * @param {Event} [options.event]
=======
     * @param {Event} options.event
>>>>>>> features/task-display-and-function
     * @return {Promise<Response>}
     *
     * @private
     */
<<<<<<< HEAD
    _getNetworkPromise({ timeoutId, request, logs, event }: {
        request: Request;
        logs: any[];
        timeoutId?: number;
        event?: ExtendableEvent;
    }): Promise<Response>;
    /**
     * Used if the network timeouts or fails to make the request.
     *
     * @param {Object} options
     * @param {Request} request The request to match in the cache
     * @param {Event} [options.event]
     * @return {Promise<Object>}
     *
     * @private
     */
    private _respondFromCache;
=======
    _getNetworkPromise({ timeoutId, request, logs, handler, }: {
        request: Request;
        logs: any[];
        timeoutId?: number;
        handler: StrategyHandler;
    }): Promise<Response | undefined>;
>>>>>>> features/task-display-and-function
}
export { NetworkFirst };
