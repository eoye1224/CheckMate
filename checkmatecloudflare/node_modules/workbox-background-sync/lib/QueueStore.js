/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { assert } from 'workbox-core/_private/assert.js';
<<<<<<< HEAD
import { DBWrapper } from 'workbox-core/_private/DBWrapper.js';
import '../_version.js';
const DB_VERSION = 3;
const DB_NAME = 'workbox-background-sync';
const OBJECT_STORE_NAME = 'requests';
const INDEXED_PROP = 'queueName';
=======
import { QueueDb, } from './QueueDb.js';
import '../_version.js';
>>>>>>> features/task-display-and-function
/**
 * A class to manage storing requests from a Queue in IndexedDB,
 * indexed by their queue name for easier access.
 *
<<<<<<< HEAD
 * @private
=======
 * Most developers will not need to access this class directly;
 * it is exposed for advanced use cases.
>>>>>>> features/task-display-and-function
 */
export class QueueStore {
    /**
     * Associates this instance with a Queue instance, so entries added can be
     * identified by their queue name.
     *
     * @param {string} queueName
<<<<<<< HEAD
     * @private
     */
    constructor(queueName) {
        this._queueName = queueName;
        this._db = new DBWrapper(DB_NAME, DB_VERSION, {
            onupgradeneeded: this._upgradeDb,
        });
=======
     */
    constructor(queueName) {
        this._queueName = queueName;
        this._queueDb = new QueueDb();
>>>>>>> features/task-display-and-function
    }
    /**
     * Append an entry last in the queue.
     *
     * @param {Object} entry
     * @param {Object} entry.requestData
     * @param {number} [entry.timestamp]
     * @param {Object} [entry.metadata]
<<<<<<< HEAD
     * @private
=======
>>>>>>> features/task-display-and-function
     */
    async pushEntry(entry) {
        if (process.env.NODE_ENV !== 'production') {
            assert.isType(entry, 'object', {
                moduleName: 'workbox-background-sync',
                className: 'QueueStore',
                funcName: 'pushEntry',
                paramName: 'entry',
            });
            assert.isType(entry.requestData, 'object', {
                moduleName: 'workbox-background-sync',
                className: 'QueueStore',
                funcName: 'pushEntry',
                paramName: 'entry.requestData',
            });
        }
        // Don't specify an ID since one is automatically generated.
        delete entry.id;
        entry.queueName = this._queueName;
<<<<<<< HEAD
        await this._db.add(OBJECT_STORE_NAME, entry);
=======
        await this._queueDb.addEntry(entry);
>>>>>>> features/task-display-and-function
    }
    /**
     * Prepend an entry first in the queue.
     *
     * @param {Object} entry
     * @param {Object} entry.requestData
     * @param {number} [entry.timestamp]
     * @param {Object} [entry.metadata]
<<<<<<< HEAD
     * @private
=======
>>>>>>> features/task-display-and-function
     */
    async unshiftEntry(entry) {
        if (process.env.NODE_ENV !== 'production') {
            assert.isType(entry, 'object', {
                moduleName: 'workbox-background-sync',
                className: 'QueueStore',
                funcName: 'unshiftEntry',
                paramName: 'entry',
            });
            assert.isType(entry.requestData, 'object', {
                moduleName: 'workbox-background-sync',
                className: 'QueueStore',
                funcName: 'unshiftEntry',
                paramName: 'entry.requestData',
            });
        }
<<<<<<< HEAD
        const [firstEntry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
            count: 1,
        });
        if (firstEntry) {
            // Pick an ID one less than the lowest ID in the object store.
            entry.id = firstEntry.id - 1;
=======
        const firstId = await this._queueDb.getFirstEntryId();
        if (firstId) {
            // Pick an ID one less than the lowest ID in the object store.
            entry.id = firstId - 1;
>>>>>>> features/task-display-and-function
        }
        else {
            // Otherwise let the auto-incrementor assign the ID.
            delete entry.id;
        }
        entry.queueName = this._queueName;
<<<<<<< HEAD
        await this._db.add(OBJECT_STORE_NAME, entry);
=======
        await this._queueDb.addEntry(entry);
>>>>>>> features/task-display-and-function
    }
    /**
     * Removes and returns the last entry in the queue matching the `queueName`.
     *
<<<<<<< HEAD
     * @return {Promise<Object>}
     * @private
     */
    async popEntry() {
        return this._removeEntry({ direction: 'prev' });
=======
     * @return {Promise<QueueStoreEntry|undefined>}
     */
    async popEntry() {
        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));
>>>>>>> features/task-display-and-function
    }
    /**
     * Removes and returns the first entry in the queue matching the `queueName`.
     *
<<<<<<< HEAD
     * @return {Promise<Object>}
     * @private
     */
    async shiftEntry() {
        return this._removeEntry({ direction: 'next' });
=======
     * @return {Promise<QueueStoreEntry|undefined>}
     */
    async shiftEntry() {
        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));
>>>>>>> features/task-display-and-function
    }
    /**
     * Returns all entries in the store matching the `queueName`.
     *
<<<<<<< HEAD
     * @param {Object} options See {@link module:workbox-background-sync.Queue~getAll}
     * @return {Promise<Array<Object>>}
     * @private
     */
    async getAll() {
        return await this._db.getAllMatching(OBJECT_STORE_NAME, {
            index: INDEXED_PROP,
            query: IDBKeyRange.only(this._queueName),
        });
=======
     * @param {Object} options See {@link workbox-background-sync.Queue~getAll}
     * @return {Promise<Array<Object>>}
     */
    async getAll() {
        return await this._queueDb.getAllEntriesByQueueName(this._queueName);
    }
    /**
     * Returns the number of entries in the store matching the `queueName`.
     *
     * @param {Object} options See {@link workbox-background-sync.Queue~size}
     * @return {Promise<number>}
     */
    async size() {
        return await this._queueDb.getEntryCountByQueueName(this._queueName);
>>>>>>> features/task-display-and-function
    }
    /**
     * Deletes the entry for the given ID.
     *
<<<<<<< HEAD
     * WARNING: this method does not ensure the deleted enry belongs to this
=======
     * WARNING: this method does not ensure the deleted entry belongs to this
>>>>>>> features/task-display-and-function
     * queue (i.e. matches the `queueName`). But this limitation is acceptable
     * as this class is not publicly exposed. An additional check would make
     * this method slower than it needs to be.
     *
<<<<<<< HEAD
     * @private
     * @param {number} id
     */
    async deleteEntry(id) {
        await this._db.delete(OBJECT_STORE_NAME, id);
=======
     * @param {number} id
     */
    async deleteEntry(id) {
        await this._queueDb.deleteEntry(id);
>>>>>>> features/task-display-and-function
    }
    /**
     * Removes and returns the first or last entry in the queue (based on the
     * `direction` argument) matching the `queueName`.
     *
<<<<<<< HEAD
     * @return {Promise<Object>}
     * @private
     */
    async _removeEntry({ direction }) {
        const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {
            direction,
            index: INDEXED_PROP,
            query: IDBKeyRange.only(this._queueName),
            count: 1,
        });
        if (entry) {
            await this.deleteEntry(entry.id);
            return entry;
        }
    }
    /**
     * Upgrades the database given an `upgradeneeded` event.
     *
     * @param {Event} event
     * @private
     */
    _upgradeDb(event) {
        const db = event.target.result;
        if (event.oldVersion > 0 && event.oldVersion < DB_VERSION) {
            if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {
                db.deleteObjectStore(OBJECT_STORE_NAME);
            }
        }
        const objStore = db.createObjectStore(OBJECT_STORE_NAME, {
            autoIncrement: true,
            keyPath: 'id',
        });
        objStore.createIndex(INDEXED_PROP, INDEXED_PROP, { unique: false });
=======
     * @return {Promise<QueueStoreEntry|undefined>}
     * @private
     */
    async _removeEntry(entry) {
        if (entry) {
            await this.deleteEntry(entry.id);
        }
        return entry;
>>>>>>> features/task-display-and-function
    }
}
