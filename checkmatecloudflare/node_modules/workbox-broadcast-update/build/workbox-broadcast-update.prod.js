<<<<<<< HEAD
this.workbox=this.workbox||{},this.workbox.broadcastUpdate=function(t,a,o,s){"use strict";try{self["workbox:broadcast-update:5.1.4"]&&_()}catch(t){}const e=(t,a,o)=>!o.some(o=>t.headers.has(o)&&a.headers.has(o))||o.every(o=>{const s=t.headers.has(o)===a.headers.has(o),e=t.headers.get(o)===a.headers.get(o);return s&&e}),n=["content-length","etag","last-modified"],i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);function c(t){return{cacheName:t.cacheName,updatedURL:t.request.url}}class r{constructor({headersToCheck:t,generatePayload:a}={}){this.t=t||n,this.o=a||c}async notifyIfUpdated(t){if(t.oldResponse&&!e(t.oldResponse,t.newResponse,this.t)){const s={type:"CACHE_UPDATED",meta:"workbox-broadcast-update",payload:this.o(t)};if("navigate"===t.request.mode){let s;t.event instanceof FetchEvent&&(s=t.event.resultingClientId);await o.resultingClientExists(s)&&!i||await a.timeout(3500)}const e=await self.clients.matchAll({type:"window"});for(const t of e)t.postMessage(s)}}}return t.BroadcastCacheUpdate=r,t.BroadcastUpdatePlugin=class{constructor(t){this.cacheDidUpdate=async t=>{s.dontWaitFor(this.s.notifyIfUpdated(t))},this.s=new r(t)}},t.responsesAreSame=e,t}({},workbox.core._private,workbox.core._private,workbox.core._private);
=======
this.workbox=this.workbox||{},this.workbox.broadcastUpdate=function(t,s,a,e){"use strict";try{self["workbox:broadcast-update:6.5.4"]&&_()}catch(t){}const n=(t,s,a)=>!a.some((a=>t.headers.has(a)&&s.headers.has(a)))||a.every((a=>{const e=t.headers.has(a)===s.headers.has(a),n=t.headers.get(a)===s.headers.get(a);return e&&n})),i=["content-length","etag","last-modified"],o=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);function c(t){return{cacheName:t.cacheName,updatedURL:t.request.url}}class r{constructor({generatePayload:t,headersToCheck:s,notifyAllClients:a}={}){this.C=s||i,this.A=t||c,this.U=null==a||a}async notifyIfUpdated(t){if(t.oldResponse&&!n(t.oldResponse,t.newResponse,this.C)){const e={type:"CACHE_UPDATED",meta:"workbox-broadcast-update",payload:this.A(t)};if("navigate"===t.request.mode){let e;t.event instanceof FetchEvent&&(e=t.event.resultingClientId);await a.resultingClientExists(e)&&!o||await s.timeout(3500)}if(this.U){const t=await self.clients.matchAll({type:"window"});for(const s of t)s.postMessage(e)}else if(t.event instanceof FetchEvent){const s=await self.clients.get(t.event.clientId);null==s||s.postMessage(e)}}}}return t.BroadcastCacheUpdate=r,t.BroadcastUpdatePlugin=class{constructor(t){this.cacheDidUpdate=async t=>{e.dontWaitFor(this.F.notifyIfUpdated(t))},this.F=new r(t)}},t.responsesAreSame=n,t}({},workbox.core._private,workbox.core._private,workbox.core._private);
>>>>>>> features/task-display-and-function
//# sourceMappingURL=workbox-broadcast-update.prod.js.map
