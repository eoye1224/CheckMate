"use strict";
<<<<<<< HEAD

=======
>>>>>>> features/task-display-and-function
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
<<<<<<< HEAD
const {
  matchPart
} = require('webpack').ModuleFilenameHelpers;

const transformManifest = require('workbox-build/build/lib/transform-manifest');

const getAssetHash = require('./get-asset-hash');

const resolveWebpackURL = require('./resolve-webpack-url');
=======
Object.defineProperty(exports, "__esModule", { value: true });
exports.getManifestEntriesFromCompilation = void 0;
const webpack_1 = require("webpack");
const transform_manifest_1 = require("workbox-build/build/lib/transform-manifest");
const get_asset_hash_1 = require("./get-asset-hash");
const resolve_webpack_url_1 = require("./resolve-webpack-url");
>>>>>>> features/task-display-and-function
/**
 * For a given asset, checks whether at least one of the conditions matches.
 *
 * @param {Asset} asset The webpack asset in question. This will be passed
 * to any functions that are listed as conditions.
 * @param {Compilation} compilation The webpack compilation. This will be passed
 * to any functions that are listed as conditions.
 * @param {Array<string|RegExp|Function>} conditions
 * @return {boolean} Whether or not at least one condition matches.
 * @private
 */
<<<<<<< HEAD


function checkConditions(asset, compilation, conditions = []) {
  for (const condition of conditions) {
    if (typeof condition === 'function') {
      if (condition({
        asset,
        compilation
      })) {
        return true;
      }
    } else {
      if (matchPart(asset.name, condition)) {
        return true;
      }
    }
  } // We'll only get here if none of the conditions applied.


  return false;
}
/**
 * Creates a mapping of an asset name to an Set of zero or more chunk names
 * that the asset is associated with.
 *
 * Those chunk names come from a combination of the `chunkName` property on the
 * asset, as well as the `stats.namedChunkGroups` property. That is the only
 * way to find out if an asset has an implicit descendent relationship with a
 * chunk, if it was, e.g., created by `SplitChunksPlugin`.
 *
 * See https://github.com/GoogleChrome/workbox/issues/1859
 * See https://github.com/webpack/webpack/issues/7073
 *
 * @param {Object} stats The webpack compilation stats.
 * @return {object<string, Set<string>>}
 * @private
 */


function assetToChunkNameMapping(stats) {
  const mapping = {};

  for (const asset of stats.assets) {
    mapping[asset.name] = new Set(asset.chunkNames);
  }

  for (const [chunkName, {
    assets
  }] of Object.entries(stats.namedChunkGroups)) {
    for (const assetName of assets) {
      // See https://github.com/GoogleChrome/workbox/issues/2194
      if (mapping[assetName]) {
        mapping[assetName].add(chunkName);
      }
    }
  }

  return mapping;
=======
function checkConditions(asset, compilation, conditions = []) {
    for (const condition of conditions) {
        if (typeof condition === 'function') {
            return condition({ asset, compilation });
            //return compilation !== null;
        }
        else {
            if (webpack_1.ModuleFilenameHelpers.matchPart(asset.name, condition)) {
                return true;
            }
        }
    }
    // We'll only get here if none of the conditions applied.
    return false;
}
/**
 * Returns the names of all the assets in all the chunks in a chunk group,
 * if provided a chunk group name.
 * Otherwise, if provided a chunk name, return all the assets in that chunk.
 * Otherwise, if there isn't a chunk group or chunk with that name, return null.
 *
 * @param {Compilation} compilation
 * @param {string} chunkOrGroup
 * @return {Array<string>|null}
 * @private
 */
function getNamesOfAssetsInChunkOrGroup(compilation, chunkOrGroup) {
    const chunkGroup = compilation.namedChunkGroups &&
        compilation.namedChunkGroups.get(chunkOrGroup);
    if (chunkGroup) {
        const assetNames = [];
        for (const chunk of chunkGroup.chunks) {
            assetNames.push(...getNamesOfAssetsInChunk(chunk));
        }
        return assetNames;
    }
    else {
        const chunk = compilation.namedChunks && compilation.namedChunks.get(chunkOrGroup);
        if (chunk) {
            return getNamesOfAssetsInChunk(chunk);
        }
    }
    // If we get here, there's no chunkGroup or chunk with that name.
    return null;
}
/**
 * Returns the names of all the assets in a chunk.
 *
 * @param {Chunk} chunk
 * @return {Array<string>}
 * @private
 */
function getNamesOfAssetsInChunk(chunk) {
    const assetNames = [];
    assetNames.push(...chunk.files);
    // This only appears to be set in webpack v5.
    if (chunk.auxiliaryFiles) {
        assetNames.push(...chunk.auxiliaryFiles);
    }
    return assetNames;
>>>>>>> features/task-display-and-function
}
/**
 * Filters the set of assets out, based on the configuration options provided:
 * - chunks and excludeChunks, for chunkName-based criteria.
 * - include and exclude, for more general criteria.
 *
 * @param {Compilation} compilation The webpack compilation.
 * @param {Object} config The validated configuration, obtained from the plugin.
 * @return {Set<Asset>} The assets that should be included in the manifest,
 * based on the criteria provided.
 * @private
 */
<<<<<<< HEAD


function filterAssets(compilation, config) {
  const filteredAssets = new Set(); // See https://webpack.js.org/configuration/stats/#stats
  // We only need assets and chunkGroups here.

  const stats = compilation.getStats().toJson({
    assets: true,
    chunkGroups: true
  });
  const assetNameToChunkNames = assetToChunkNameMapping(stats); // See https://github.com/GoogleChrome/workbox/issues/1287

  if (Array.isArray(config.chunks)) {
    for (const chunk of config.chunks) {
      if (!(chunk in stats.namedChunkGroups)) {
        compilation.warnings.push(`The chunk '${chunk}' was provided in ` + `your Workbox chunks config, but was not found in the compilation.`);
      }
    }
  } // See https://webpack.js.org/api/stats/#asset-objects


  for (const asset of stats.assets) {
    // chunkName based filtering is funky because:
    // - Each asset might belong to one or more chunkNames.
    // - If *any* of those chunk names match our config.excludeChunks,
    //   then we skip that asset.
    // - If the config.chunks is defined *and* there's no match
    //   between at least one of the chunkNames and one entry, then
    //   we skip that assets as well.
    const isExcludedChunk = Array.isArray(config.excludeChunks) && config.excludeChunks.some(chunkName => {
      return assetNameToChunkNames[asset.name].has(chunkName);
    });

    if (isExcludedChunk) {
      continue;
    }

    const isIncludedChunk = !Array.isArray(config.chunks) || config.chunks.some(chunkName => {
      return assetNameToChunkNames[asset.name].has(chunkName);
    });

    if (!isIncludedChunk) {
      continue;
    } // Next, check asset-level checks via includes/excludes:


    const isExcluded = checkConditions(asset, compilation, config.exclude);

    if (isExcluded) {
      continue;
    } // Treat an empty config.includes as an implicit inclusion.


    const isIncluded = !Array.isArray(config.include) || checkConditions(asset, compilation, config.include);

    if (!isIncluded) {
      continue;
    } // If we've gotten this far, then add the asset.


    filteredAssets.add(asset);
  }

  return filteredAssets;
}

module.exports = async (compilation, config) => {
  const filteredAssets = filterAssets(compilation, config);
  const {
    publicPath
  } = compilation.options.output;
  const fileDetails = [];

  for (const asset of filteredAssets) {
    // Not sure why this would be false, but checking just in case, since
    // our original list of assets comes from compilation.getStats().toJson(),
    // not from compilation.assets.
    if (asset.name in compilation.assets) {
      // This matches the format expected by transformManifest().
      fileDetails.push({
        file: resolveWebpackURL(publicPath, asset.name),
        hash: getAssetHash(compilation.assets[asset.name]),
        size: asset.size || 0
      });
    } else {
      compilation.warnings.push(`Could not precache ${asset.name}, as it's ` + `missing from compilation.assets. Please open a bug against Workbox ` + `with details about your webpack config.`);
    }
  } // We also get back `size` and `count`, and it would be nice to log that
  // somewhere, but... webpack doesn't offer info-level logs?
  // https://github.com/webpack/webpack/issues/3996


  const {
    manifestEntries,
    warnings
  } = await transformManifest({
    fileDetails,
    additionalManifestEntries: config.additionalManifestEntries,
    dontCacheBustURLsMatching: config.dontCacheBustURLsMatching,
    manifestTransforms: config.manifestTransforms,
    maximumFileSizeToCacheInBytes: config.maximumFileSizeToCacheInBytes,
    modifyURLPrefix: config.modifyURLPrefix,
    transformParam: compilation
  });
  compilation.warnings = compilation.warnings.concat(warnings || []); // Ensure that the entries are properly sorted by URL.

  const sortedEntries = manifestEntries.sort((a, b) => a.url === b.url ? 0 : a.url > b.url ? 1 : -1);
  return sortedEntries;
};
=======
function filterAssets(compilation, config) {
    const filteredAssets = new Set();
    const assets = compilation.getAssets();
    const allowedAssetNames = new Set();
    // See https://github.com/GoogleChrome/workbox/issues/1287
    if (Array.isArray(config.chunks)) {
        for (const name of config.chunks) {
            // See https://github.com/GoogleChrome/workbox/issues/2717
            const assetsInChunkOrGroup = getNamesOfAssetsInChunkOrGroup(compilation, name);
            if (assetsInChunkOrGroup) {
                for (const assetName of assetsInChunkOrGroup) {
                    allowedAssetNames.add(assetName);
                }
            }
            else {
                compilation.warnings.push(new Error(`The chunk '${name}' was ` +
                    `provided in your Workbox chunks config, but was not found in the ` +
                    `compilation.`));
            }
        }
    }
    const deniedAssetNames = new Set();
    if (Array.isArray(config.excludeChunks)) {
        for (const name of config.excludeChunks) {
            // See https://github.com/GoogleChrome/workbox/issues/2717
            const assetsInChunkOrGroup = getNamesOfAssetsInChunkOrGroup(compilation, name);
            if (assetsInChunkOrGroup) {
                for (const assetName of assetsInChunkOrGroup) {
                    deniedAssetNames.add(assetName);
                }
            } // Don't warn if the chunk group isn't found.
        }
    }
    for (const asset of assets) {
        // chunk based filtering is funky because:
        // - Each asset might belong to one or more chunks.
        // - If *any* of those chunk names match our config.excludeChunks,
        //   then we skip that asset.
        // - If the config.chunks is defined *and* there's no match
        //   between at least one of the chunkNames and one entry, then
        //   we skip that assets as well.
        if (deniedAssetNames.has(asset.name)) {
            continue;
        }
        if (Array.isArray(config.chunks) && !allowedAssetNames.has(asset.name)) {
            continue;
        }
        // Next, check asset-level checks via includes/excludes:
        const isExcluded = checkConditions(asset, compilation, config.exclude);
        if (isExcluded) {
            continue;
        }
        // Treat an empty config.includes as an implicit inclusion.
        const isIncluded = !Array.isArray(config.include) ||
            checkConditions(asset, compilation, config.include);
        if (!isIncluded) {
            continue;
        }
        // If we've gotten this far, then add the asset.
        filteredAssets.add(asset);
    }
    return filteredAssets;
}
async function getManifestEntriesFromCompilation(compilation, config) {
    const filteredAssets = filterAssets(compilation, config);
    const { publicPath } = compilation.options.output;
    const fileDetails = Array.from(filteredAssets).map((asset) => {
        return {
            file: (0, resolve_webpack_url_1.resolveWebpackURL)(publicPath, asset.name),
            hash: (0, get_asset_hash_1.getAssetHash)(asset),
            size: asset.source.size() || 0,
        };
    });
    const { manifestEntries, size, warnings } = await (0, transform_manifest_1.transformManifest)({
        fileDetails,
        additionalManifestEntries: config.additionalManifestEntries,
        dontCacheBustURLsMatching: config.dontCacheBustURLsMatching,
        manifestTransforms: config.manifestTransforms,
        maximumFileSizeToCacheInBytes: config.maximumFileSizeToCacheInBytes,
        modifyURLPrefix: config.modifyURLPrefix,
        transformParam: compilation,
    });
    // See https://github.com/GoogleChrome/workbox/issues/2790
    for (const warning of warnings) {
        compilation.warnings.push(new Error(warning));
    }
    // Ensure that the entries are properly sorted by URL.
    const sortedEntries = manifestEntries.sort((a, b) => a.url === b.url ? 0 : a.url > b.url ? 1 : -1);
    return { size, sortedEntries };
}
exports.getManifestEntriesFromCompilation = getManifestEntriesFromCompilation;
>>>>>>> features/task-display-and-function
