/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD
"use strict";

const validateOptions = require("schema-utils");
const schema = require("../schemas/plugins/IgnorePlugin.json");

/** @typedef {import("../declarations/plugins/IgnorePlugin").IgnorePluginOptions} IgnorePluginOptions */
/** @typedef {import("./Compiler")} Compiler */
=======

"use strict";

const RawModule = require("./RawModule");
const EntryDependency = require("./dependencies/EntryDependency");
const createSchemaValidation = require("./util/create-schema-validation");

/** @typedef {import("../declarations/plugins/IgnorePlugin").IgnorePluginOptions} IgnorePluginOptions */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./NormalModuleFactory").ResolveData} ResolveData */

const validate = createSchemaValidation(
	require("../schemas/plugins/IgnorePlugin.check.js"),
	() => require("../schemas/plugins/IgnorePlugin.json"),
	{
		name: "Ignore Plugin",
		baseDataPath: "options"
	}
);
>>>>>>> features/task-display-and-function

class IgnorePlugin {
	/**
	 * @param {IgnorePluginOptions} options IgnorePlugin options
	 */
	constructor(options) {
<<<<<<< HEAD
		// TODO webpack 5 remove this compat-layer
		if (arguments.length > 1 || options instanceof RegExp) {
			options = {
				resourceRegExp: arguments[0],
				contextRegExp: arguments[1]
			};
		}

		validateOptions(schema, options, "IgnorePlugin");
		this.options = options;

		/** @private @type {Function} */
=======
		validate(options);
		this.options = options;

		/**
		 * @private
		 * @type {Function}
		 */
>>>>>>> features/task-display-and-function
		this.checkIgnore = this.checkIgnore.bind(this);
	}

	/**
<<<<<<< HEAD
	 * Note that if "contextRegExp" is given, both the "resourceRegExp"
	 * and "contextRegExp" have to match.
	 *
	 * @param {TODO} result result
	 * @returns {TODO|null} returns result or null if result should be ignored
	 */
	checkIgnore(result) {
		if (!result) return result;

		if (
			"checkResource" in this.options &&
			this.options.checkResource &&
			this.options.checkResource(result.request, result.context)
		) {
			// TODO webpack 5 remove checkContext, as checkResource already gets context
			if ("checkContext" in this.options && this.options.checkContext) {
				if (this.options.checkContext(result.context)) {
					return null;
				}
			} else {
				return null;
			}
=======
	 * Note that if "contextRegExp" is given, both the "resourceRegExp" and "contextRegExp" have to match.
	 * @param {ResolveData} resolveData resolve data
	 * @returns {false|undefined} returns false when the request should be ignored, otherwise undefined
	 */
	checkIgnore(resolveData) {
		if (
			"checkResource" in this.options &&
			this.options.checkResource &&
			this.options.checkResource(resolveData.request, resolveData.context)
		) {
			return false;
>>>>>>> features/task-display-and-function
		}

		if (
			"resourceRegExp" in this.options &&
			this.options.resourceRegExp &&
<<<<<<< HEAD
			this.options.resourceRegExp.test(result.request)
=======
			this.options.resourceRegExp.test(resolveData.request)
>>>>>>> features/task-display-and-function
		) {
			if ("contextRegExp" in this.options && this.options.contextRegExp) {
				// if "contextRegExp" is given,
				// both the "resourceRegExp" and "contextRegExp" have to match.
<<<<<<< HEAD
				if (this.options.contextRegExp.test(result.context)) {
					return null;
				}
			} else {
				return null;
			}
		}

		return result;
	}

	/**
	 * @param {Compiler} compiler Webpack Compiler
=======
				if (this.options.contextRegExp.test(resolveData.context)) {
					return false;
				}
			} else {
				return false;
			}
		}
	}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
>>>>>>> features/task-display-and-function
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.normalModuleFactory.tap("IgnorePlugin", nmf => {
<<<<<<< HEAD
			nmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
=======
			nmf.hooks.beforeResolve.tap("IgnorePlugin", resolveData => {
				const result = this.checkIgnore(resolveData);

				if (
					result === false &&
					resolveData.dependencies.length > 0 &&
					resolveData.dependencies[0] instanceof EntryDependency
				) {
					resolveData.ignoredModule = new RawModule(
						"",
						"ignored-entry-module",
						"(ignored-entry-module)"
					);
				}

				return result;
			});
>>>>>>> features/task-display-and-function
		});
		compiler.hooks.contextModuleFactory.tap("IgnorePlugin", cmf => {
			cmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
		});
	}
}

module.exports = IgnorePlugin;
