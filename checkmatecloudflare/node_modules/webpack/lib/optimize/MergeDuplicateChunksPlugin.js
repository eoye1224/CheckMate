/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD
"use strict";

class MergeDuplicateChunksPlugin {
=======

"use strict";

const { STAGE_BASIC } = require("../OptimizationStages");
const createSchemaValidation = require("../util/create-schema-validation");
const { runtimeEqual } = require("../util/runtime");

/** @typedef {import("../../declarations/plugins/optimize/MergeDuplicateChunksPlugin").MergeDuplicateChunksPluginOptions} MergeDuplicateChunksPluginOptions */
/** @typedef {import("../Compiler")} Compiler */

const validate = createSchemaValidation(
	require("../../schemas/plugins/optimize/MergeDuplicateChunksPlugin.check.js"),
	() =>
		require("../../schemas/plugins/optimize/MergeDuplicateChunksPlugin.json"),
	{
		name: "Merge Duplicate Chunks Plugin",
		baseDataPath: "options"
	}
);

class MergeDuplicateChunksPlugin {
	/**
	 * @param {MergeDuplicateChunksPluginOptions} options options object
	 */
	constructor(options = { stage: STAGE_BASIC }) {
		validate(options);
		this.options = options;
	}

	/**
	 * @param {Compiler} compiler the compiler
	 * @returns {void}
	 */
>>>>>>> features/task-display-and-function
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"MergeDuplicateChunksPlugin",
			compilation => {
<<<<<<< HEAD
				compilation.hooks.optimizeChunksBasic.tap(
					"MergeDuplicateChunksPlugin",
					chunks => {
=======
				compilation.hooks.optimizeChunks.tap(
					{
						name: "MergeDuplicateChunksPlugin",
						stage: this.options.stage
					},
					chunks => {
						const { chunkGraph, moduleGraph } = compilation;

>>>>>>> features/task-display-and-function
						// remember already tested chunks for performance
						const notDuplicates = new Set();

						// for each chunk
						for (const chunk of chunks) {
							// track a Set of all chunk that could be duplicates
							let possibleDuplicates;
<<<<<<< HEAD
							for (const module of chunk.modulesIterable) {
=======
							for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
>>>>>>> features/task-display-and-function
								if (possibleDuplicates === undefined) {
									// when possibleDuplicates is not yet set,
									// create a new Set from chunks of the current module
									// including only chunks with the same number of modules
<<<<<<< HEAD
									for (const dup of module.chunksIterable) {
										if (
											dup !== chunk &&
											chunk.getNumberOfModules() === dup.getNumberOfModules() &&
=======
									for (const dup of chunkGraph.getModuleChunksIterable(
										module
									)) {
										if (
											dup !== chunk &&
											chunkGraph.getNumberOfChunkModules(chunk) ===
												chunkGraph.getNumberOfChunkModules(dup) &&
>>>>>>> features/task-display-and-function
											!notDuplicates.has(dup)
										) {
											// delay allocating the new Set until here, reduce memory pressure
											if (possibleDuplicates === undefined) {
												possibleDuplicates = new Set();
											}
											possibleDuplicates.add(dup);
										}
									}
									// when no chunk is possible we can break here
									if (possibleDuplicates === undefined) break;
								} else {
									// validate existing possible duplicates
									for (const dup of possibleDuplicates) {
										// remove possible duplicate when module is not contained
<<<<<<< HEAD
										if (!dup.containsModule(module)) {
=======
										if (!chunkGraph.isModuleInChunk(module, dup)) {
>>>>>>> features/task-display-and-function
											possibleDuplicates.delete(dup);
										}
									}
									// when all chunks has been removed we can break here
									if (possibleDuplicates.size === 0) break;
								}
							}

							// when we found duplicates
							if (
								possibleDuplicates !== undefined &&
								possibleDuplicates.size > 0
							) {
<<<<<<< HEAD
								for (const otherChunk of possibleDuplicates) {
									if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;
									// merge them
									if (chunk.integrate(otherChunk, "duplicate")) {
										chunks.splice(chunks.indexOf(otherChunk), 1);
=======
								outer: for (const otherChunk of possibleDuplicates) {
									if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;
									if (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;
									if (chunkGraph.getNumberOfEntryModules(otherChunk) > 0)
										continue;
									if (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {
										for (const module of chunkGraph.getChunkModulesIterable(
											chunk
										)) {
											const exportsInfo = moduleGraph.getExportsInfo(module);
											if (
												!exportsInfo.isEquallyUsed(
													chunk.runtime,
													otherChunk.runtime
												)
											) {
												continue outer;
											}
										}
									}
									// merge them
									if (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {
										chunkGraph.integrateChunks(chunk, otherChunk);
										compilation.chunks.delete(otherChunk);
>>>>>>> features/task-display-and-function
									}
								}
							}

							// don't check already processed chunks twice
							notDuplicates.add(chunk);
						}
					}
				);
			}
		);
	}
}
module.exports = MergeDuplicateChunksPlugin;
