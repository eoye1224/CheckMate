/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD
"use strict";

class AggressiveMergingPlugin {
=======

"use strict";

const { STAGE_ADVANCED } = require("../OptimizationStages");

/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../Compiler")} Compiler */

/**
 * @typedef {object} AggressiveMergingPluginOptions
 * @property {number=} minSizeReduce minimal size reduction to trigger merging
 */

class AggressiveMergingPlugin {
	/**
	 * @param {AggressiveMergingPluginOptions=} [options] options object
	 */
>>>>>>> features/task-display-and-function
	constructor(options) {
		if (
			(options !== undefined && typeof options !== "object") ||
			Array.isArray(options)
		) {
			throw new Error(
				"Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/"
			);
		}
		this.options = options || {};
	}

<<<<<<< HEAD
=======
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
>>>>>>> features/task-display-and-function
	apply(compiler) {
		const options = this.options;
		const minSizeReduce = options.minSizeReduce || 1.5;

		compiler.hooks.thisCompilation.tap(
			"AggressiveMergingPlugin",
			compilation => {
<<<<<<< HEAD
				compilation.hooks.optimizeChunksAdvanced.tap(
					"AggressiveMergingPlugin",
					chunks => {
						let combinations = [];
						chunks.forEach((a, idx) => {
							if (a.canBeInitial()) return;
							for (let i = 0; i < idx; i++) {
								const b = chunks[i];
								if (b.canBeInitial()) continue;
								combinations.push({
									a,
									b,
									improvement: undefined
								});
							}
						});

						for (const pair of combinations) {
							const a = pair.b.size({
								chunkOverhead: 0
							});
							const b = pair.a.size({
								chunkOverhead: 0
							});
							const ab = pair.b.integratedSize(pair.a, {
								chunkOverhead: 0
							});
							let newSize;
							if (ab === false) {
								pair.improvement = false;
								return;
							} else {
								newSize = ab;
							}

							pair.improvement = (a + b) / newSize;
						}
						combinations = combinations.filter(pair => {
							return pair.improvement !== false;
						});
						combinations.sort((a, b) => {
							return b.improvement - a.improvement;
						});
=======
				compilation.hooks.optimizeChunks.tap(
					{
						name: "AggressiveMergingPlugin",
						stage: STAGE_ADVANCED
					},
					chunks => {
						const chunkGraph = compilation.chunkGraph;
						/** @type {{a: Chunk, b: Chunk, improvement: number}[]} */
						const combinations = [];
						for (const a of chunks) {
							if (a.canBeInitial()) continue;
							for (const b of chunks) {
								if (b.canBeInitial()) continue;
								if (b === a) break;
								if (!chunkGraph.canChunksBeIntegrated(a, b)) {
									continue;
								}
								const aSize = chunkGraph.getChunkSize(b, {
									chunkOverhead: 0
								});
								const bSize = chunkGraph.getChunkSize(a, {
									chunkOverhead: 0
								});
								const abSize = chunkGraph.getIntegratedChunksSize(b, a, {
									chunkOverhead: 0
								});
								const improvement = (aSize + bSize) / abSize;
								combinations.push({
									a,
									b,
									improvement
								});
							}
						}

						combinations.sort((a, b) => b.improvement - a.improvement);
>>>>>>> features/task-display-and-function

						const pair = combinations[0];

						if (!pair) return;
						if (pair.improvement < minSizeReduce) return;

<<<<<<< HEAD
						if (pair.b.integrate(pair.a, "aggressive-merge")) {
							chunks.splice(chunks.indexOf(pair.a), 1);
							return true;
						}
=======
						chunkGraph.integrateChunks(pair.b, pair.a);
						compilation.chunks.delete(pair.a);
						return true;
>>>>>>> features/task-display-and-function
					}
				);
			}
		);
	}
}

module.exports = AggressiveMergingPlugin;
