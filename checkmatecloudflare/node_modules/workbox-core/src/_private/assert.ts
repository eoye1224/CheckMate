/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

<<<<<<< HEAD
import {WorkboxError, WorkboxErrorDetails} from '../_private/WorkboxError.js';
=======
import {WorkboxError} from '../_private/WorkboxError.js';
import {MapLikeObject} from '../types.js';
>>>>>>> features/task-display-and-function
import '../_version.js';

/*
 * This method throws if the supplied value is not an array.
 * The destructed values are required to produce a meaningful error for users.
 * The destructed and restructured object is so it's clear what is
 * needed.
 */
<<<<<<< HEAD
const isArray = (
  value: any[],
  details: WorkboxErrorDetails,
) => {
=======
const isArray = (value: any[], details: MapLikeObject) => {
>>>>>>> features/task-display-and-function
  if (!Array.isArray(value)) {
    throw new WorkboxError('not-an-array', details);
  }
};

const hasMethod = (
<<<<<<< HEAD
  object: {[key: string]: any},
  expectedMethod: string,
  details: WorkboxErrorDetails,
=======
  object: MapLikeObject,
  expectedMethod: string,
  details: MapLikeObject,
>>>>>>> features/task-display-and-function
) => {
  const type = typeof object[expectedMethod];
  if (type !== 'function') {
    details['expectedMethod'] = expectedMethod;
    throw new WorkboxError('missing-a-method', details);
  }
};

const isType = (
<<<<<<< HEAD
  object: {},
  expectedType: string,
  details: WorkboxErrorDetails,
=======
  object: unknown,
  expectedType: string,
  details: MapLikeObject,
>>>>>>> features/task-display-and-function
) => {
  if (typeof object !== expectedType) {
    details['expectedType'] = expectedType;
    throw new WorkboxError('incorrect-type', details);
  }
};

const isInstance = (
<<<<<<< HEAD
  object: {},
  expectedClass: Function,
  details: WorkboxErrorDetails,
) => {
  if (!(object instanceof expectedClass)) {
    details['expectedClass'] = expectedClass;
=======
  object: unknown,
  // Need the general type to do the check later.
  // eslint-disable-next-line @typescript-eslint/ban-types
  expectedClass: Function,
  details: MapLikeObject,
) => {
  if (!(object instanceof expectedClass)) {
    details['expectedClassName'] = expectedClass.name;
>>>>>>> features/task-display-and-function
    throw new WorkboxError('incorrect-class', details);
  }
};

<<<<<<< HEAD
const isOneOf = (
  value: any,
  validValues: any[],
  details: WorkboxErrorDetails) => {
  if (!validValues.includes(value)) {
    details['validValueDescription'] =
        `Valid values are ${JSON.stringify(validValues)}.`
=======
const isOneOf = (value: any, validValues: any[], details: MapLikeObject) => {
  if (!validValues.includes(value)) {
    details['validValueDescription'] = `Valid values are ${JSON.stringify(
      validValues,
    )}.`;
>>>>>>> features/task-display-and-function
    throw new WorkboxError('invalid-value', details);
  }
};

const isArrayOfClass = (
  value: any,
<<<<<<< HEAD
  expectedClass: Function,
  details: WorkboxErrorDetails,
=======
  // Need general type to do check later.
  expectedClass: Function, // eslint-disable-line
  details: MapLikeObject,
>>>>>>> features/task-display-and-function
) => {
  const error = new WorkboxError('not-array-of-class', details);
  if (!Array.isArray(value)) {
    throw error;
  }

  for (const item of value) {
    if (!(item instanceof expectedClass)) {
      throw error;
    }
  }
};

<<<<<<< HEAD
const finalAssertExports = process.env.NODE_ENV === 'production' ? null : {
  hasMethod,
  isArray,
  isInstance,
  isOneOf,
  isType,
  isArrayOfClass,
};
=======
const finalAssertExports =
  process.env.NODE_ENV === 'production'
    ? null
    : {
        hasMethod,
        isArray,
        isInstance,
        isOneOf,
        isType,
        isArrayOfClass,
      };
>>>>>>> features/task-display-and-function

export {finalAssertExports as assert};
