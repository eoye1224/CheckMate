<<<<<<< HEAD
# Enforce that `this` is used when only `this` type is returned (`prefer-return-this-type`)

[Method chaining](https://en.wikipedia.org/wiki/Method_chaining) is a common pattern in OOP languages and TypeScript provides a special [polymorphic this type](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-types).
If any type other than `this` is specified as the return type of these chaining methods, TypeScript will fail to cast it when invoking in subclass.
=======
---
description: 'Enforce that `this` is used when only `this` type is returned.'
---

> 🛑 This file is source code, not the primary documentation location! 🛑
>
> See **https://typescript-eslint.io/rules/prefer-return-this-type** for documentation.

[Method chaining](https://en.wikipedia.org/wiki/Method_chaining) is a common pattern in OOP languages and TypeScript provides a special [polymorphic `this` type](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-types) to facilitate it.
Class methods that explicitly declare a return type of the class name instead of `this` make it harder for extending classes to call that method: the returned object will be typed as the base class, not the derived class.

This rule reports when a class method declares a return type of that class name instead of `this`.
>>>>>>> features/task-display-and-function

```ts
class Animal {
  eat(): Animal {
<<<<<<< HEAD
=======
    //   ~~~~~~
    // Either removing this type annotation or replacing
    // it with `this` would remove the type error below.
>>>>>>> features/task-display-and-function
    console.log("I'm moving!");
    return this;
  }
}

class Cat extends Animal {
  meow(): Cat {
    console.log('Meow~');
    return this;
  }
}

const cat = new Cat();
<<<<<<< HEAD
// Error: Property 'meow' does not exist on type 'Animal'.
// because `eat` returns `Animal` and not all animals meow.
cat.eat().meow();

// the error can be fixed by removing the return type of `eat` or use `this` as the return type.
class Animal {
  eat(): this {
    console.log("I'm moving!");
    return this;
  }
}

class Cat extends Animal {
  meow(): this {
    console.log('Meow~');
    return this;
  }
}

const cat = new Cat();
// no errors. Because `eat` returns `Cat` now
cat.eat().meow();
```

Examples of **incorrect** code for this rule:
=======
cat.eat().meow();
//        ~~~~
// Error: Property 'meow' does not exist on type 'Animal'.
// because `eat` returns `Animal` and not all animals meow.
```

## Examples

<!--tabs-->

### ❌ Incorrect
>>>>>>> features/task-display-and-function

```ts
class Foo {
  f1(): Foo {
    return this;
  }
  f2 = (): Foo => {
    return this;
  };
  f3(): Foo | undefined {
    return Math.random() > 0.5 ? this : undefined;
  }
}
```

<<<<<<< HEAD
Examples of **correct** code for this rule:
=======
### ✅ Correct
>>>>>>> features/task-display-and-function

```ts
class Foo {
  f1(): this {
    return this;
  }
  f2() {
    return this;
  }
  f3 = (): this => {
    return this;
  };
  f4 = () => {
    return this;
  };
}

class Base {}
class Derived extends Base {
  f(): Base {
    return this;
  }
}
```

## When Not To Use It

If you don't use method chaining or explicit return values, you can safely turn this rule off.
